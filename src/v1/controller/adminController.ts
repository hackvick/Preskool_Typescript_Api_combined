// import mongoose from "mongoose"
import express, { Response, Request, NextFunction } from "express";
import { UserModels, AdminModels } from "../../models/index";
import { userInterface } from "../../models/adminModel/ModelNewUser";
import {
  error_Object,
  resp_Object,
  response_handler,
  object_id_check,
  responseType,
  Ilogin,
} from "../../utils/helperFun";
// import {} from "../../utils/helperFun";
import { MESSAGES } from "../../utils/message";
import bcrypt from "bcrypt";
import http from "http-status-codes";
import { create } from "../../services/operation";
import { 
    Controller,
    Route,
    Get,
    Post,Put,Delete,Tags,Body,Security,Example,} from "tsoa";
import { genAuthToken } from "../../utils/auth";
// console.log(http,"http");
let refreshTokens: any = [];

export default {
  SingleUserDetail,
};

@Tags("Admin")
@Route("/admin")
export class AdminController extends Controller {
  req: Request;
  res: Response;
  userId: string;
  userRole: number;
  constructor(req: Request, res: Response) {
      super();
      this.req = req;
      this.res = res;
      this.userId = req.body.user ? req.body.user._id : ''
      this.userRole = req.body.user ? req.body.user.role : null
  }
  @Security("Bearer")
  @Get("/users")
  public async User_detailsfun(): Promise<responseType | any>{
    try {

        console.log(this.userId,"userid token ");
        
      const users_details = await AdminModels.ModelNewUser.find(
        { role: 3 },
        "father_name mobileNum fname gender"
      );
      const response = new resp_Object(
        MESSAGES.DATA_RETREIVE_SUCCESSFULLY,
        http.OK,
        users_details
      );
      return { CatchResponse: response };
    } catch (error) {
      return { CatchError: error };
    }
  }

  @Post("/user/create")
  public async New_Users(
    @Body()
    request: {
      role: number;
      fname: string;
      lname: string;
      email: string;
      mobileNum: number;
      password: string;
      gender: string;
      username: string;
      father_name: string;
      mother_name: string;
      religion: string;
    }
  ): Promise<responseType | any>{
    try {
      const salt = await bcrypt.genSalt(10);
      const body = request;
      //  logic part of autogenerated username
      const today = new Date();
      const year = today.getFullYear().toString();
      const yearcode = parseInt(year.slice(-2));
      const usercount = await AdminModels.ModelNewUser.find({
        role: 3,
      }).count();
      const count: any = (usercount + 1).toString();
      const usercode = count.padStart(2, 0);
      // check if user alreday exist or not
      const finduser = await AdminModels.ModelNewUser.findOne({
        email: body.email,
      });
      console.log(finduser);
      if (finduser)
        throw new error_Object(
          MESSAGES.USER_ALREADY_REGISTERED,
          http.UNPROCESSABLE_ENTITY
        );
      body.password = await bcrypt.hash(body.password, salt);
      // // const student_img = req.file.path;
      // // Student_Data.student_img = student_img;

      // assigning a auto generated username to the user
      Object.assign(body, { username: "PS" + yearcode + usercode });

      const UserSaved = await create(body, AdminModels.ModelNewUser);
      //   await new AdminModels.ModelNewUser<userInterface>(body).save();
      const response = new resp_Object(
        MESSAGES.USER_REGISTERED_SUCCESSFULLY,
        http.CREATED,
        UserSaved
      );
      return { CatchResponse: response };
    } catch (error: any) {
      console.log(error, "err catchhhh side ");
      return { CatchError: error };
    }
  }
  @Security("Bearer")
  @Put("/user/update/:id")
  public async Update_userfun(
    @Body()
    request: {
      role: number;
      fname: string;
      lname: string;
      email: string;
      mobileNum: number;
      password: string;
      gender: string;
      father_name: string;
      religion: string;
    },
    id: string
  ): Promise<responseType | any> {
    try {
      const user_id = id;
      console.log(user_id, "idd");

      const body = request;
      console.log(body, "body or request");

      if (!body)
        throw new error_Object(
          "Something Not Right Data Not Recieved Please Enter Data",
          http.EXPECTATION_FAILED
        );

      const find = await AdminModels.ModelNewUser.findOne({ _id: user_id });
      if (!find)
        throw new error_Object(
          MESSAGES.DOES_NOT_EXIST,
          http.EXPECTATION_FAILED
        );

      const UserUpdated = await AdminModels.ModelNewUser.findByIdAndUpdate(
        user_id,
        body,
        { new: true }
      );
      const response = new resp_Object(
        MESSAGES.UPDATED_SUCCESSFULLY,
        http.CREATED
      );
      return { CatchResponse: response };
    } catch (error) {
      // console.log("something not right" + error);
      return { CatchError: error };
    }
  }
  @Security("Bearer")
  @Delete("/user/delete/:id")
  public async Delete_Userfun(id: string): Promise<responseType | any> {
    try {
      const user_id = id;
      console.log(user_id);
      const find = await AdminModels.ModelNewUser.findOne({ _id: user_id });
      if (!find)
        throw new error_Object(
          MESSAGES.DOES_NOT_EXIST,
          http.EXPECTATION_FAILED
        );

      const deleted = await AdminModels.ModelNewUser.findByIdAndDelete(user_id);
      const response = new resp_Object(
        MESSAGES.DELETED_SUCCESSFULLY,
        http.ACCEPTED
      );
      return { CatchResponse: response };
    } catch (error) {
      // console.log("something not right" + error);
      return { CatchError: error };
    }
  }

  @Post("/user/login")
  public async UserLoginFun(
    @Body() request: { password: string; email: string }
  ): Promise<responseType | any> {
    try {
      console.log(request, "request");

      const { email, password } = request;
      console.log(email, password, "email passs");
      // find if user exist or not
      const Userdata = await AdminModels.ModelNewUser.findOne({ email: email });
      if (!Userdata)
        throw new error_Object(MESSAGES.USER_NOT_VALID, http.UNAUTHORIZED);
      const user_id = Userdata._id;

      // await bcrypt.compare(request.Lpassword, loginuser.Password)
      if (await bcrypt.compare(password, Userdata.password)) {
        //generating jwt token
        const token = genAuthToken(user_id);
        if (!token)
          throw new error_Object(MESSAGES.TOKEN_NOT_GENERATED, http.NOT_FOUND);
        //   console.log(token, "token login side");
        refreshTokens.push(token.refresh_token);
        const response = new resp_Object(
          MESSAGES.LOGIN_SUCCESSFULLY,
          http.ACCEPTED,
          {
            AccessToken: token.Access_token,
            RefreshToken: token.refresh_token,
          }
        );

        return { CatchResponse: response };
      } else {
        throw new error_Object(
          MESSAGES.PASSWORD_NOT_MATCHED,
          http.UNAUTHORIZED
        );
      }
    } catch (error) {
      return { CatchError: error };
    }
  }

  @Security("Bearer")
  @Get("/hello")
  public async helloUser(): Promise<responseType | any> {
    try {
      const response = new resp_Object(
        "Hello User Authenticated Successfully",
        202
      );
      return { CatchResponse: response };
    } catch (error) {
      return { CatchError: error };
    }
  }
}

async function SingleUserDetail(
  req: Request,
  res: Response,
  next: NextFunction
) {
  try {
    const user_id = req.params.id;
    const userdata = await AdminModels.ModelNewUser.find(
      { _id: user_id },
      { password: 0 }
    );
    const response = new resp_Object(
      MESSAGES.DATA_RETREIVE_SUCCESSFULLY,
      http.OK,
      userdata
    );
    res.send(response);
  } catch (error) {
    next(error);
  }
}
